@startuml interrupt_flow
title Worker Abandonment Flow

participant "Game" as game
participant "Engine" as engine
participant "Chef" as chef
participant "Kitchen" as kitchen

== Chef is working at kitchen ==
chef -> kitchen : executing step...

== Enemy Appears ==
game -> game : detect enemy
note right: Game decides chef\nmust stop cooking

== Abandon Work ==
game -> engine : abandonWork(chef_id)
engine -> chef : state = Idle
engine -> kitchen : status = Blocked\n(step progress preserved)
engine -> kitchen : assigned_worker = null

note over kitchen
  Kitchen keeps current_step intact.
  When resources available again,
  another worker can resume from
  where the chef left off.
end note

== Fight Handling ==
note over game
  Game handles fight logic
  outside of task engine.
  Engine is not aware of fights.
end note

== After Fight ==
game -> engine : notifyWorkerIdle(chef_id)
note right: Chef is available again

== Resume Kitchen ==
game -> engine : notifyResourcesAvailable(kitchen_id)
engine -> engine : findBestWorker(kitchen_id, ...)
alt chef is best worker
  engine -> chef : state = Working
  engine -> kitchen : status = Active
  engine -> game : onStepStarted(chef_id, kitchen_id, current_step)
  note right: Resumes from preserved step
else different worker
  note right: Another worker picks up\nwhere chef left off
end

@enduml
